# GitHub Models 学習ガイド

## 概要

GitHub Modelsは、AIモデルの検索、テスト、評価、本番環境への統合を支援する開発者向けツールスイートです。複数のAIモデル（GPT-4、Claude、Gemini等）を無料で試用でき、プロンプトの最適化、モデル間の比較、定量的な評価を通じて、最適なAI駆動型アプリケーションを構築できます。

**具体的に何ができるのか：**

1. **コードレビューボットの開発**：GPT-4とClaude 3.5を同時にテストし、どちらがより建設的なフィードバックを提供するか比較。レスポンス時間とコストを可視化し、最適なモデルを選定できます。

2. **多言語カスタマーサポート**：日本語の問い合わせを英語に翻訳→回答生成→日本語に再翻訳する一連の処理で、各ステップに最適なモデルを選択。類似性スコアで翻訳品質を数値化して評価できます。

3. **ドキュメント自動生成**：同じコードに対して複数のモデルでドキュメントを生成し、技術的正確性（根拠性スコア）と読みやすさ（関連性スコア）を定量的に比較。プロンプトをYAMLファイルとして保存し、チーム全体で共有・改善できます。

**なぜすごいのか：**
- **即座に開始**：APIキーの取得不要、GitHubアカウントだけで主要AIモデルをテスト
- **定量的な評価**：「なんとなく良い」ではなく、数値で品質を比較
- **チーム開発に最適**：プロンプトをコードと同様にレビュー、バージョン管理
- **コスト削減**：本番環境移行前に最適なモデルを選定し、無駄な出費を防止

このガイドでは、Git学習アシスタントの構築を例に、GitHub Modelsの基本的な使い方から本番環境への統合まで、実践的に学習します。

## 学習目標

このチュートリアルを完了すると、以下のことができるようになります：

- GitHub Modelsの基本概念と機能を理解する
- プロンプトエディターを使用してAIモデルをテストする
- 複数のモデルとプロンプトのバリエーションを比較評価する
- エバリュエーターを使用してモデル出力を定量的に評価する
- プロンプト設定をリポジトリに保存し、チームで共有する
- GitHub ActionsやCLIを通じてモデルを統合する

## 前提条件

- GitHubアカウント
- 基本的なGitの知識
- （オプション）GitHub Copilotサブスクリプション

## シナリオ：Git学習アシスタントの構築

このチュートリアルでは、コマンドラインからGitを学習するユーザーを支援するAIアシスタントを構築します。このシナリオを通じて、GitHub Modelsの主要機能を実践的に学習します。

## ステップ1：環境の準備

### 1.1 テスト用リポジトリの作成

1. [新しいリポジトリ](https://github.com/new)ページにアクセス
2. リポジトリ名：`git-learning-assistant`
3. プライベートリポジトリとして作成
4. **リポジトリの作成**をクリック

### 1.2 GitHub Modelsの有効化

1. リポジトリの設定ページを開く
2. サイドバーの**モデル**をクリック
3. GitHub Modelsを有効化

## ステップ2：基本的なプロンプトの作成

### 2.1 プロンプトエディターを開く

1. リポジトリの**モデル**タブをクリック
2. **新しいプロンプト**をクリック

### 2.2 システムプロンプトの設定

システムプロンプトフィールドに以下を入力：

```text
あなたはGitバージョン管理システムの専門家です。
ユーザーがコマンドラインからGitを使用する方法について質問した際、
明確で段階的な説明を提供してください。
各ステップを丁寧に説明し、初心者にも理解しやすいようにしてください。
```

### 2.3 ユーザープロンプトの設定

ユーザープロンプトフィールドに以下を入力：

```text
Gitの使い方を学びたいです。{{topic}}について教えてください。
```

### 2.4 変数の設定

1. **変数**ボタンをクリック
2. `{{topic}}`フィールドに以下を入力：

```text
ブランチの作成と切り替え
```

### 2.5 プロンプトの実行

右上の**再生**ボタンをクリックして、モデルの応答を確認します。

## ステップ3：複数モデルの比較

### 3.1 比較ビューへの切り替え

1. 左上の**比較**をクリック
2. **プロンプトを追加**→**元のプロンプトをコピー**を2回実行

### 3.2 異なるモデルの選択

各プロンプトに対して異なるモデルを選択：
- プロンプト1：GPT-4o
- プロンプト2：Claude 3.5 Sonnet
- プロンプト3：Gemini 1.5 Pro

### 3.3 テスト入力の追加

**入力を追加**をクリックして、以下のテスト入力を追加：

| 入力 | 内容 |
|------|------|
| 1 | リベースとマージの違いと使い分け |
| 2 | 直前のコミットメッセージを修正する方法 |
| 3 | 特定のコミットを別のブランチに移動する方法 |
| 4 | リポジトリ履歴から特定のコミットの作者を見つける方法 |

### 3.4 比較の実行

**実行**をクリックして、各モデルの応答を比較します。以下の点に注目：
- レイテンシー（応答速度）
- トークン使用量（コスト）
- 応答の品質と正確性

## ステップ4：プロンプトバリエーションのテスト

### 4.1 同じモデルで異なるプロンプトを比較

すべてのプロンプトで同じモデル（例：GPT-4o）を選択し、ユーザープロンプトを変更：

**プロンプト1（標準）：**
```text
Gitの使い方を学びたいです。{{topic}}について教えてください。
```

**プロンプト2（初心者向け）：**
```text
Gitを初めて使います。{{topic}}について、5歳児にもわかるように説明してください。
```

**プロンプト3（上級者向け）：**
```text
Gitの{{topic}}について、内部動作も含めて技術的に詳しく説明してください。
```

### 4.2 結果の評価

各プロンプトバリエーションの応答を比較し、ターゲットユーザーに最適なものを選択します。

## ステップ5：エバリュエーターによる評価

### 5.1 エバリュエーターの追加

1. **エバリュエーターを追加**をクリック
2. 以下のエバリュエーターを設定：

**類似性エバリュエーター：**
- 期待される出力を定義し、各モデルの応答がどれだけ近いかを評価

**関連性エバリュエーター：**
- 入力に対する応答の関連性を評価

**文字列チェック：**
- 名前：「コマンド例の確認」
- 値：`git`
- 応答にGitコマンドが含まれているかを確認

### 5.2 評価の実行と分析

**実行**をクリックして、各エバリュエーターのスコアを確認します。

## ステップ6：プロンプトの保存と共有

### 6.1 プロンプト設定の保存

1. プロンプトに名前を付ける：`git-learning-assistant`
2. **変更をコミット**をクリック
3. コミットメッセージを入力して保存

### 6.2 YAMLファイルの確認

保存されたプロンプトは`.prompt.yml`ファイルとして保存されます：

```yaml
name: git-learning-assistant
description: Gitコマンドの使い方を説明するアシスタント
model: gpt-4o
modelParameters:
  temperature: 0.3
  max_tokens: 1000
messages:
  - role: system
    content: |
      あなたはGitバージョン管理システムの専門家です。
      ユーザーがコマンドラインからGitを使用する方法について質問した際、
      明確で段階的な説明を提供してください。
  - role: user
    content: Gitの使い方を学びたいです。{{topic}}について教えてください。
testData:
  - topic: ブランチの作成と切り替え
    expected: ブランチの作成にはgit branchコマンドを使用し...
```

// ...existing code...

## ステップ7：本番環境への統合

### 7.1 GitHub Actionsでの使用

**このセクションで実現すること：**
GitHub Actionsワークフローから保存済みのプロンプト設定（`.prompt.yml`）を使って、AIモデルを自動的に呼び出す仕組みを構築します。これにより、Issueが作成されたときに自動的にAIがGitの使い方を回答するヘルプデスクのような機能を実装できます。

**なぜこれが便利なのか：**
- **24時間365日対応**: 人間のサポートを待たずに即座に回答
- **一貫性のある品質**: 事前に調整したプロンプトで常に同じ品質の回答
- **完全自動化**: 手動でAIに聞いてコピペする必要がない
- **履歴の保存**: Issueとコメントとして記録が残る

**実際の動作フロー：**
1. ユーザーがタイトルに `[Git Help]` を含むIssueを作成
2. GitHub Actionsが自動的に起動
3. Issueの本文（質問内容）を取得
4. 保存済みの `git-learning-assistant.prompt.yml` を使ってAIに質問を送信
5. AIが生成した回答をIssueのコメントとして自動投稿

`.github/workflows/git-help.yml`を作成：

```yaml
name: Git Help Issue Comments
on:
  issues:
    types: [opened]
    
permissions:
  issues: write      # Issueにコメントを投稿するため
  contents: read     # プロンプトファイルを読み取るため
  models: read       # GitHub Modelsを使用するため

jobs:
  provide_git_help:
    runs-on: ubuntu-latest
    # タイトルに[Git Help]が含まれる場合のみ実行
    if: contains(github.event.issue.title, '[Git Help]')
    steps:
      # リポジトリのコードをチェックアウト（プロンプトファイルを読み込むため）
      - uses: actions/checkout@v4
      
      # GitHub Models拡張機能をインストール
      - name: Install gh-models extension
        run: gh extension install https://github.com/github/gh-models
        env:
          GH_TOKEN: ${{ github.token }}
          
      # AIモデルを実行してGitの使い方を説明
      - name: Generate Git help
        run: |
          echo "${{ github.event.issue.body }}" | 
          gh models run --file git-learning-assistant.prompt.yml > response.txt
        env:
          GH_TOKEN: ${{ github.token }}
          
      # AIの回答をIssueのコメントとして投稿
      - name: Post response
        run: |
          gh issue comment ${{ github.event.issue.number }} --body-file response.txt
        env:
          GH_TOKEN: ${{ github.token }}
```

**実際の使用例：**
```
Issue タイトル: [Git Help] リベースについて教えて
Issue 本文: git rebaseの基本的な使い方と、mergeとの違いを教えてください

↓ 自動的に以下のようなコメントが投稿される ↓

AIアシスタント: 
git rebaseは、コミット履歴を整理するための強力なツールです。

## 基本的な使い方
1. 現在のブランチを最新の状態に更新
   ```bash
   git rebase main
   ```

2. インタラクティブリベース（コミットの編集）
   ```bash
   git rebase -i HEAD~3
   ```

## mergeとの違い
- **merge**: 履歴を保持したまま統合（マージコミットが作成される）
- **rebase**: 履歴を書き換えて直線的にする（よりクリーンな履歴）

...（以下、詳細な説明が続く）
```

### 7.2 CLIでの使用

**このセクションで実現すること：**
コマンドラインから直接GitHub Modelsを呼び出し、保存済みのプロンプト設定を使ってAIに質問できるようにします。これにより、開発中にターミナルを離れることなくGitの使い方を調べられます。

**なぜこれが便利なのか：**
- **開発フローを中断しない**: ブラウザを開かずにターミナルで完結
- **コマンドの出力を直接質問**: パイプを使って実際のGitコマンドの結果を基に質問
- **スクリプトに組み込み可能**: 自動化ツールの一部として使用可能
- **オフライン対応**: プロンプトファイルはローカルに保存されている

**実際の動作フロー：**
1. GitHub CLI拡張機能をインストール
2. プロンプトファイルを指定してAIモデルを実行
3. 結果がターミナルに直接表示される

```bash
# 拡張機能のインストール（初回のみ）
gh extension install https://github.com/github/gh-models

# 基本的な使い方：単純な質問
echo "リベースの使い方" | gh models run --file git-learning-assistant.prompt.yml

# 実践的な使い方1：gitコマンドの結果を基に質問
git status | gh models run --file git-learning-assistant.prompt.yml \
  --prompt "このgit statusの結果を解説してください"

# 実践的な使い方2：エラーメッセージの解決方法を聞く
git rebase main 2>&1 | gh models run --file git-learning-assistant.prompt.yml \
  --prompt "このエラーの解決方法を教えてください"

# 実践的な使い方3：複雑なgit logの結果を要約
git log --graph --oneline -10 | gh models run --file git-learning-assistant.prompt.yml \
  --prompt "このコミット履歴を要約して、何が行われたか説明してください"
```

**具体的な使用例：**
```bash
# シナリオ：マージコンフリクトが発生した場合
$ git merge feature-branch
Auto-merging src/main.js
CONFLICT (content): Merge conflict in src/main.js
Automatic merge failed; fix conflicts and then commit the result.

# AIに解決方法を聞く
$ git status | gh models run --file git-learning-assistant.prompt.yml \
    --prompt "このマージコンフリクトを解決する手順を教えてください"

# AIの回答：
マージコンフリクトが src/main.js で発生しています。以下の手順で解決してください：

1. コンフリクトが発生したファイルを開く
   $ code src/main.js  # または好きなエディタで開く

2. コンフリクトマーカーを探す
   <<<<<<< HEAD
   現在のブランチの内容
   =======
   マージしようとしているブランチの内容
   >>>>>>> feature-branch

3. どちらの変更を採用するか、または両方を組み合わせるか決定

4. コンフリクトマーカーを削除して保存

5. 変更をステージング
   $ git add src/main.js

6. マージを完了
   $ git commit

詳細な説明が必要な場合は、具体的なコンフリクト内容を共有してください。
```

**プロンプトファイルのカスタマイズ例：**
開発チーム向けに特化したプロンプトファイルを作成することも可能：

```yaml
# team-git-helper.prompt.yml
name: team-git-helper
description: 開発チームのGit運用ルールに基づくアシスタント
model: gpt-4o
modelParameters:
  temperature: 0.3
  max_tokens: 1500
messages:
  - role: system
    content: |
      あなたは開発チームのGit運用をサポートするアシスタントです。
      以下のチームルールに基づいて回答してください：
      - feature/*、bugfix/*、hotfix/* のブランチ命名規則
      - コミットメッセージは日本語で記述
      - プルリクエスト前にrebaseで履歴を整理
      - mainブランチへの直接pushは禁止
  - role: user
    content: "{{query}}"
```

これらの詳細な説明により、学習者は単にコマンドをコピペするだけでなく、何をしているのか、なぜそれが有用なのかを理解した上で実装できるようになります。

## ベストプラクティス

### プロンプトエンジニアリング
- 明確で具体的な指示を提供
- 変数を使用して再利用可能なプロンプトを作成
- 期待される出力形式を明示

### モデル選択
- タスクの複雑さに応じたモデルを選択
- コストとパフォーマンスのバランスを考慮
- レイテンシー要件に基づいて選択

### 評価とテスト
- 複数のテストケースを用意
- エバリュエーターを使用して定量的に評価
- 継続的にプロンプトを改善

### セキュリティとガバナンス
- 組織のポリシーに準拠
- センシティブなデータを含めない
- アクセス権限を適切に管理

## トラブルシューティング

### よくある問題と解決方法

**問題：モデルが期待通りの応答を返さない**
- 解決：プロンプトをより具体的に調整
- 温度パラメーターを下げて一貫性を向上

**問題：レート制限エラー**
- 解決：リクエストの頻度を調整
- 有料プランへのアップグレードを検討

**問題：トークン制限の超過**
- 解決：max_tokensパラメーターを調整
- プロンプトを簡潔に

## まとめ

このチュートリアルでは、GitHub Modelsを使用してAI駆動型アプリケーションを構築する方法を学習しました。主な学習内容：

1. プロンプトエディターでの基本的なプロンプト作成
2. 複数モデルの比較評価
3. プロンプトバリエーションのテスト
4. エバリュエーターによる定量的評価
5. プロンプト設定の保存と共有
6. GitHub ActionsやCLIとの統合

これらのスキルを活用して、独自のAI駆動型アプリケーションを構築してください。

## 次のステップ

- [GitHub Models REST API](https://docs.github.com/ja/rest/models)を使用したプログラマティックな統合
- エンタープライズ環境でのGitHub Modelsの管理
- カスタムエバリュエーターの作成
- より複雑なプロンプトチェーンの構築

## リソース

- [GitHub Models ドキュメント](https://docs.github.com/ja/github-models)
- [GitHub Models ディスカッション](https://github.com/orgs/community/discussions/categories/models)
- [サンプルプロンプト集](https://github.com/topics/github-models-prompts)